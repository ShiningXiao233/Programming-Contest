# D

从二维DP的方式思考，然后通过信息压缩一维，原本是 $dp_{i,j}$ 表示两个属性分别为 $i,j$ 的情况，由于 $i+j$ 是固定的，所以用 $dp_i$ 表示即可。

# E

主要思路：将第一行的卡牌拿出来与其他行进行抵消。

需要分析一行的情况，即分配 $m$ 张牌，总共平衡了 $k$ 对的分配法。

不能简单的用卡特兰数+组合来实现，存在问题。

考虑第一行，使用 $w_{i,j}$ 表示分配了 $i$ 张牌，其中 $j$ 张牌是平衡后的第一人剩余的牌，实际上作为括号匹配问题，就是不断的枚举回括号的位置。

对称问题：使用 $s_{i,j}$ 表示分配了 $i$ 张牌，其中 $j$ 张牌是平衡后的第二人剩余的牌，考虑将 $w_{i,j}$ 的方案选择 $180$ 度，则可以得到一组对应的方案，并且一一对应。所以 $w_{i,j} = s_{i,j}$。

```python
way[0][0] = 1
for i in range(0, m):
    for j in range(0, i + 1):
        way[i + 1][j + 1] += way[i][j] # [
        way[i + 1][j + 1] %= MOD
        if j > 0:
            way[i + 1][j - 1] += way[i][j] # ] 
            way[i + 1][j - 1] %= MOD
```