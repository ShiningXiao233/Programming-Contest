### E

首先可以思考到，对于 $n$ 个字符串，最多只需要一个长度为 $\log_2 n$ 的串，即可完成全部匹配。

> 对于串的第一个字符，考虑所有串的第一个字符，如果 $1$ 多，那么取一，否则取零，每次都可以减少一半的量。

所以我们可以只考虑长度为 $20$ 的一个后缀即可，前面的所有元素都取 $0$，对于所有的后缀，我们反向思考，要求每个串都匹配到至少一个，如果我们将串取反，那么就变成了所有串都不能匹配到的字典序最小，考虑使用前缀树实现即可。

用所有的反串建立一棵tire，由于树的层数一定是20，所以我们需要找到一条最小的路径，走到非叶子结点（因为每一条完整的路径，就是避开某个串的路径）。

复杂度 $O(n \log n)$ 。

#### F

几个结论：

1. 先挂长链，再挂短链。
2. 挂链时，一定是挂链的中点。
3. 挂链时，一定是取树中最小的挂。
4. 高度不会超过 $4\times 10^5$ 。

维护每个高度的结点数量，区间加法，区间求和。

可以用差分，或者是线段树。其实直接按照高度进行遍历操作即可。